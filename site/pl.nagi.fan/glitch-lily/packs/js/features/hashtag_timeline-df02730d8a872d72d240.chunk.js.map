{"version":3,"sources":["webpack:///app/javascript/builds/infra/glitch-lily/app/javascript/mastodon/features/hashtag_timeline/components/column_settings.js","webpack:///app/javascript/builds/infra/glitch-lily/app/javascript/mastodon/features/hashtag_timeline/containers/column_settings_container.js","webpack:///app/javascript/builds/infra/glitch-lily/app/javascript/mastodon/features/hashtag_timeline/index.js"],"names":["messages","defineMessages","placeholder","noOptions","ColumnSettings","injectIntl","React","PureComponent","state","open","this","hasTags","onSelect","mode","value","oldValue","tags","length","props","onChange","onToggle","setState","noOptionsMessage","intl","formatMessage","map","includes","settings","getIn","toJS","modeSelect","className","modeLabel","nonce","document","querySelector","content","cacheKey","isMulti","autoFocus","loadOptions","onLoad","classNamePrefix","name","id","defaultMessage","render","checked","settingPath","label","connect","columnId","columns","index","findIndex","c","get","api","params","q","type","then","response","data","hashtags","tag","dispatch","key","changeColumnParams","followHashtag","unfollowHashtag","HashtagTimeline","hasUnread","local","disconnects","handlePin","removeColumn","addColumn","title","additionalFor","push","values","additional","join","handleMove","dir","moveColumn","handleHeaderClick","column","scrollTop","setRef","handleLoadMore","maxId","expandHashtagTimeline","handleFollow","_subscribe","any","all","none","connectHashtagStream","status","filter","_unsubscribe","disconnect","_unload","clearTimeline","_load","fetchHashtag","componentDidMount","componentDidUpdate","prevProps","componentWillUnmount","multiColumn","pinned","followButton","following","classNames","onClick","aria-label","aria-pressed","fixedWidth","bindToDocument","ref","icon","active","onPin","onMove","extraButton","showBackButton","trackScroll","scrollKey","timelineId","onLoadMore","emptyMessage"],"mappings":"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","file":"js/features/hashtag_timeline-df02730d8a872d72d240.chunk.js","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport ImmutablePropTypes from 'react-immutable-proptypes';\nimport { defineMessages, injectIntl, FormattedMessage } from 'react-intl';\nimport Toggle from 'react-toggle';\nimport AsyncSelect from 'react-select/async';\nimport { NonceProvider } from 'react-select';\nimport SettingToggle from '../../notifications/components/setting_toggle';\n\nconst messages = defineMessages({\n  placeholder: { id: 'hashtag.column_settings.select.placeholder', defaultMessage: 'Enter hashtagsâ€¦' },\n  noOptions: { id: 'hashtag.column_settings.select.no_options_message', defaultMessage: 'No suggestions found' },\n});\n\nexport default @injectIntl\nclass ColumnSettings extends React.PureComponent {\n\n  static propTypes = {\n    settings: ImmutablePropTypes.map.isRequired,\n    onChange: PropTypes.func.isRequired,\n    onLoad: PropTypes.func.isRequired,\n    intl: PropTypes.object.isRequired,\n  };\n\n  state = {\n    open: this.hasTags(),\n  };\n\n  hasTags () {\n    return ['all', 'any', 'none'].map(mode => this.tags(mode).length > 0).includes(true);\n  }\n\n  tags (mode) {\n    let tags = this.props.settings.getIn(['tags', mode]) || [];\n\n    if (tags.toJS) {\n      return tags.toJS();\n    } else {\n      return tags;\n    }\n  };\n\n  onSelect = mode => value => {\n    const oldValue = this.tags(mode);\n\n    // Prevent changes that add more than 4 tags, but allow removing\n    // tags that were already added before\n    if ((value.length > 4) && !(value < oldValue)) {\n      return;\n    }\n\n    this.props.onChange(['tags', mode], value);\n  };\n\n  onToggle = () => {\n    if (this.state.open && this.hasTags()) {\n      this.props.onChange('tags', {});\n    }\n\n    this.setState({ open: !this.state.open });\n  };\n\n  noOptionsMessage = () => this.props.intl.formatMessage(messages.noOptions);\n\n  modeSelect (mode) {\n    return (\n      <div className='column-settings__row'>\n        <span className='column-settings__section'>\n          {this.modeLabel(mode)}\n        </span>\n\n        <NonceProvider nonce={document.querySelector('meta[name=style-nonce]').content} cacheKey='tags'>\n          <AsyncSelect\n            isMulti\n            autoFocus\n            value={this.tags(mode)}\n            onChange={this.onSelect(mode)}\n            loadOptions={this.props.onLoad}\n            className='column-select__container'\n            classNamePrefix='column-select'\n            name='tags'\n            placeholder={this.props.intl.formatMessage(messages.placeholder)}\n            noOptionsMessage={this.noOptionsMessage}\n          />\n        </NonceProvider>\n      </div>\n    );\n  }\n\n  modeLabel (mode) {\n    switch(mode) {\n    case 'any':\n      return <FormattedMessage id='hashtag.column_settings.tag_mode.any' defaultMessage='Any of these' />;\n    case 'all':\n      return <FormattedMessage id='hashtag.column_settings.tag_mode.all' defaultMessage='All of these' />;\n    case 'none':\n      return <FormattedMessage id='hashtag.column_settings.tag_mode.none' defaultMessage='None of these' />;\n    default:\n      return '';\n    }\n  };\n\n  render () {\n    const { settings, onChange } = this.props;\n\n    return (\n      <div>\n        <div className='column-settings__row'>\n          <div className='setting-toggle'>\n            <Toggle id='hashtag.column_settings.tag_toggle' onChange={this.onToggle} checked={this.state.open} />\n\n            <span className='setting-toggle__label'>\n              <FormattedMessage id='hashtag.column_settings.tag_toggle' defaultMessage='Include additional tags in this column' />\n            </span>\n          </div>\n        </div>\n\n        {this.state.open && (\n          <div className='column-settings__hashtags'>\n            {this.modeSelect('any')}\n            {this.modeSelect('all')}\n            {this.modeSelect('none')}\n          </div>\n        )}\n\n        <div className='column-settings__row'>\n          <SettingToggle settings={settings} settingPath={['local']} onChange={onChange} label={<FormattedMessage id='community.column_settings.local_only' defaultMessage='Local only' />} />\n        </div>\n      </div>\n    );\n  }\n\n}\n","import { connect } from 'react-redux';\nimport ColumnSettings from '../components/column_settings';\nimport { changeColumnParams } from '../../../actions/columns';\nimport api from '../../../api';\n\nconst mapStateToProps = (state, { columnId }) => {\n  const columns = state.getIn(['settings', 'columns']);\n  const index   = columns.findIndex(c => c.get('uuid') === columnId);\n\n  if (!(columnId && index >= 0)) {\n    return {};\n  }\n\n  return {\n    settings: columns.get(index).get('params'),\n    onLoad (value) {\n      return api(() => state).get('/api/v2/search', { params: { q: value, type: 'hashtags' } }).then(response => {\n        return (response.data.hashtags || []).map((tag) => {\n          return { value: tag.name, label: `#${tag.name}` };\n        });\n      });\n    },\n  };\n};\n\nconst mapDispatchToProps = (dispatch, { columnId }) => ({\n  onChange (key, value) {\n    dispatch(changeColumnParams(columnId, key, value));\n  },\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ColumnSettings);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport PropTypes from 'prop-types';\nimport ImmutablePropTypes from 'react-immutable-proptypes';\nimport StatusListContainer from '../ui/containers/status_list_container';\nimport Column from 'mastodon/components/column';\nimport ColumnHeader from 'mastodon/components/column_header';\nimport ColumnSettingsContainer from './containers/column_settings_container';\nimport { expandHashtagTimeline, clearTimeline } from 'mastodon/actions/timelines';\nimport { addColumn, removeColumn, moveColumn } from 'mastodon/actions/columns';\nimport { injectIntl, FormattedMessage, defineMessages } from 'react-intl';\nimport { connectHashtagStream } from 'mastodon/actions/streaming';\nimport { isEqual } from 'lodash';\nimport { fetchHashtag, followHashtag, unfollowHashtag } from 'mastodon/actions/tags';\nimport Icon from 'mastodon/components/icon';\nimport classNames from 'classnames';\n\nconst messages = defineMessages({\n  followHashtag: { id: 'hashtag.follow', defaultMessage: 'Follow hashtag' },\n  unfollowHashtag: { id: 'hashtag.unfollow', defaultMessage: 'Unfollow hashtag' },\n});\n\nconst mapStateToProps = (state, props) => ({\n  hasUnread: state.getIn(['timelines', `hashtag:${props.params.id}${props.params.local ? ':local' : ''}`, 'unread']) > 0,\n  tag: state.getIn(['tags', props.params.id]),\n});\n\nexport default @connect(mapStateToProps)\n@injectIntl\nclass HashtagTimeline extends React.PureComponent {\n\n  disconnects = [];\n\n  static propTypes = {\n    params: PropTypes.object.isRequired,\n    columnId: PropTypes.string,\n    dispatch: PropTypes.func.isRequired,\n    hasUnread: PropTypes.bool,\n    tag: ImmutablePropTypes.map,\n    multiColumn: PropTypes.bool,\n    intl: PropTypes.object,\n  };\n\n  handlePin = () => {\n    const { columnId, dispatch } = this.props;\n\n    if (columnId) {\n      dispatch(removeColumn(columnId));\n    } else {\n      dispatch(addColumn('HASHTAG', { id: this.props.params.id }));\n    }\n  }\n\n  title = () => {\n    const { id } = this.props.params;\n    const title  = [id];\n\n    if (this.additionalFor('any')) {\n      title.push(' ', <FormattedMessage key='any' id='hashtag.column_header.tag_mode.any'  values={{ additional: this.additionalFor('any') }} defaultMessage='or {additional}' />);\n    }\n\n    if (this.additionalFor('all')) {\n      title.push(' ', <FormattedMessage key='all' id='hashtag.column_header.tag_mode.all'  values={{ additional: this.additionalFor('all') }} defaultMessage='and {additional}' />);\n    }\n\n    if (this.additionalFor('none')) {\n      title.push(' ', <FormattedMessage key='none' id='hashtag.column_header.tag_mode.none' values={{ additional: this.additionalFor('none') }} defaultMessage='without {additional}' />);\n    }\n\n    return title;\n  }\n\n  additionalFor = (mode) => {\n    const { tags } = this.props.params;\n\n    if (tags && (tags[mode] || []).length > 0) {\n      return tags[mode].map(tag => tag.value).join('/');\n    } else {\n      return '';\n    }\n  }\n\n  handleMove = (dir) => {\n    const { columnId, dispatch } = this.props;\n    dispatch(moveColumn(columnId, dir));\n  }\n\n  handleHeaderClick = () => {\n    this.column.scrollTop();\n  }\n\n  _subscribe (dispatch, id, tags = {}, local) {\n    let any  = (tags.any || []).map(tag => tag.value);\n    let all  = (tags.all || []).map(tag => tag.value);\n    let none = (tags.none || []).map(tag => tag.value);\n\n    [id, ...any].map(tag => {\n      this.disconnects.push(dispatch(connectHashtagStream(id, tag, local, status => {\n        let tags = status.tags.map(tag => tag.name);\n\n        return all.filter(tag => tags.includes(tag)).length === all.length &&\n               none.filter(tag => tags.includes(tag)).length === 0;\n      })));\n    });\n  }\n\n  _unsubscribe () {\n    this.disconnects.map(disconnect => disconnect());\n    this.disconnects = [];\n  }\n\n  _unload () {\n    const { dispatch } = this.props;\n    const { id, local } = this.props.params;\n\n    this._unsubscribe();\n    dispatch(clearTimeline(`hashtag:${id}${local ? ':local' : ''}`));\n  }\n\n  _load() {\n    const { dispatch } = this.props;\n    const { id, tags, local } = this.props.params;\n\n    this._subscribe(dispatch, id, tags, local);\n    dispatch(expandHashtagTimeline(id, { tags, local }));\n    dispatch(fetchHashtag(id));\n  }\n\n  componentDidMount () {\n    this._load();\n  }\n\n  componentDidUpdate (prevProps) {\n    const { params } = this.props;\n    const { id, tags, local } = prevProps.params;\n\n    if (id !== params.id || !isEqual(tags, params.tags) || !isEqual(local, params.local)) {\n      this._unload();\n      this._load();\n    }\n  }\n\n  componentWillUnmount () {\n    this._unsubscribe();\n  }\n\n  setRef = c => {\n    this.column = c;\n  }\n\n  handleLoadMore = maxId => {\n    const { dispatch, params } = this.props;\n    const { id, tags, local }  = params;\n\n    dispatch(expandHashtagTimeline(id, { maxId, tags, local }));\n  }\n\n  handleFollow = () => {\n    const { dispatch, params, tag } = this.props;\n    const { id } = params;\n\n    if (tag.get('following')) {\n      dispatch(unfollowHashtag(id));\n    } else {\n      dispatch(followHashtag(id));\n    }\n  }\n\n  render () {\n    const { hasUnread, columnId, multiColumn, tag, intl } = this.props;\n    const { id, local } = this.props.params;\n    const pinned = !!columnId;\n\n    let followButton;\n\n    if (tag) {\n      const following = tag.get('following');\n\n      followButton = (\n        <button className={classNames('column-header__button')} onClick={this.handleFollow} title={intl.formatMessage(following ? messages.unfollowHashtag : messages.followHashtag)} aria-label={intl.formatMessage(following ? messages.unfollowHashtag : messages.followHashtag)} aria-pressed={following ? 'true' : 'false'}>\n          <Icon id={following ? 'user-times' : 'user-plus'} fixedWidth className='column-header__icon' />\n        </button>\n      );\n    }\n\n    return (\n      <Column bindToDocument={!multiColumn} ref={this.setRef} label={`#${id}`}>\n        <ColumnHeader\n          icon='hashtag'\n          active={hasUnread}\n          title={this.title()}\n          onPin={this.handlePin}\n          onMove={this.handleMove}\n          onClick={this.handleHeaderClick}\n          pinned={pinned}\n          multiColumn={multiColumn}\n          extraButton={followButton}\n          showBackButton\n        >\n          {columnId && <ColumnSettingsContainer columnId={columnId} />}\n        </ColumnHeader>\n\n        <StatusListContainer\n          trackScroll={!pinned}\n          scrollKey={`hashtag_timeline-${columnId}`}\n          timelineId={`hashtag:${id}${local ? ':local' : ''}`}\n          onLoadMore={this.handleLoadMore}\n          emptyMessage={<FormattedMessage id='empty_column.hashtag' defaultMessage='There is nothing in this hashtag yet.' />}\n          bindToDocument={!multiColumn}\n        />\n      </Column>\n    );\n  }\n\n}\n"],"sourceRoot":""}