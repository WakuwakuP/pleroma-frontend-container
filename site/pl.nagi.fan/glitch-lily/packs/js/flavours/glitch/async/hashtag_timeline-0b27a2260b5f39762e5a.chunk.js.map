{"version":3,"sources":["webpack:///app/javascript/builds/infra/glitch-lily/app/javascript/flavours/glitch/features/hashtag_timeline/components/column_settings.js","webpack:///app/javascript/builds/infra/glitch-lily/app/javascript/flavours/glitch/features/hashtag_timeline/containers/column_settings_container.js","webpack:///app/javascript/builds/infra/glitch-lily/app/javascript/flavours/glitch/actions/tags.js","webpack:///app/javascript/builds/infra/glitch-lily/app/javascript/flavours/glitch/features/hashtag_timeline/index.js"],"names":["messages","defineMessages","placeholder","noOptions","ColumnSettings","injectIntl","React","PureComponent","state","open","this","hasTags","onSelect","mode","value","oldValue","tags","length","props","onChange","onToggle","setState","noOptionsMessage","intl","formatMessage","map","includes","settings","getIn","toJS","modeSelect","className","modeLabel","nonce","document","querySelector","content","cacheKey","isMulti","autoFocus","loadOptions","onLoad","classNamePrefix","name","id","defaultMessage","render","checked","settingPath","label","connect","columnId","columns","index","findIndex","c","get","api","params","q","type","then","response","data","hashtags","tag","dispatch","key","changeColumnParams","HASHTAG_FETCH_REQUEST","HASHTAG_FETCH_SUCCESS","HASHTAG_FETCH_FAIL","fetchHashtagRequest","fetchHashtagSuccess","fetchHashtagFail","error","followHashtagRequest","followHashtagSuccess","followHashtagFail","unfollowHashtagRequest","unfollowHashtagSuccess","unfollowHashtagFail","followHashtag","unfollowHashtag","HashtagTimeline","hasUnread","local","disconnects","handlePin","removeColumn","addColumn","title","additionalFor","push","values","additional","join","handleMove","dir","moveColumn","handleHeaderClick","column","scrollTop","setRef","handleLoadMore","maxId","expandHashtagTimeline","handleFollow","getState","post","catch","err","_subscribe","any","all","none","connectHashtagStream","status","filter","_unsubscribe","disconnect","_unload","clearTimeline","_load","componentDidMount","componentDidUpdate","prevProps","componentWillUnmount","multiColumn","pinned","followButton","following","classNames","onClick","aria-label","aria-pressed","fixedWidth","bindToDocument","ref","icon","active","onPin","onMove","extraButton","showBackButton","trackScroll","scrollKey","timelineId","onLoadMore","emptyMessage"],"mappings":"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","file":"js/flavours/glitch/async/hashtag_timeline-0b27a2260b5f39762e5a.chunk.js","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport ImmutablePropTypes from 'react-immutable-proptypes';\nimport { defineMessages, injectIntl, FormattedMessage } from 'react-intl';\nimport Toggle from 'react-toggle';\nimport AsyncSelect from 'react-select/async';\nimport { NonceProvider } from 'react-select';\nimport SettingToggle from '../../notifications/components/setting_toggle';\n\nconst messages = defineMessages({\n  placeholder: { id: 'hashtag.column_settings.select.placeholder', defaultMessage: 'Enter hashtagsâ€¦' },\n  noOptions: { id: 'hashtag.column_settings.select.no_options_message', defaultMessage: 'No suggestions found' },\n});\n\nexport default @injectIntl\nclass ColumnSettings extends React.PureComponent {\n\n  static propTypes = {\n    settings: ImmutablePropTypes.map.isRequired,\n    onChange: PropTypes.func.isRequired,\n    onLoad: PropTypes.func.isRequired,\n    intl: PropTypes.object.isRequired,\n  };\n\n  state = {\n    open: this.hasTags(),\n  };\n\n  hasTags () {\n    return ['all', 'any', 'none'].map(mode => this.tags(mode).length > 0).includes(true);\n  }\n\n  tags (mode) {\n    let tags = this.props.settings.getIn(['tags', mode]) || [];\n\n    if (tags.toJS) {\n      return tags.toJS();\n    } else {\n      return tags;\n    }\n  };\n\n  onSelect = mode => value => {\n    const oldValue = this.tags(mode);\n\n    // Prevent changes that add more than 4 tags, but allow removing\n    // tags that were already added before\n    if ((value.length > 4) && !(value < oldValue)) {\n      return;\n    }\n\n    this.props.onChange(['tags', mode], value);\n  };\n\n  onToggle = () => {\n    if (this.state.open && this.hasTags()) {\n      this.props.onChange('tags', {});\n    }\n\n    this.setState({ open: !this.state.open });\n  };\n\n  noOptionsMessage = () => this.props.intl.formatMessage(messages.noOptions);\n\n  modeSelect (mode) {\n    return (\n      <div className='column-settings__row'>\n        <span className='column-settings__section'>\n          {this.modeLabel(mode)}\n        </span>\n\n        <NonceProvider nonce={document.querySelector('meta[name=style-nonce]').content} cacheKey='tags'>\n          <AsyncSelect\n            isMulti\n            autoFocus\n            value={this.tags(mode)}\n            onChange={this.onSelect(mode)}\n            loadOptions={this.props.onLoad}\n            className='column-select__container'\n            classNamePrefix='column-select'\n            name='tags'\n            placeholder={this.props.intl.formatMessage(messages.placeholder)}\n            noOptionsMessage={this.noOptionsMessage}\n          />\n        </NonceProvider>\n      </div>\n    );\n  }\n\n  modeLabel (mode) {\n    switch(mode) {\n    case 'any':\n      return <FormattedMessage id='hashtag.column_settings.tag_mode.any' defaultMessage='Any of these' />;\n    case 'all':\n      return <FormattedMessage id='hashtag.column_settings.tag_mode.all' defaultMessage='All of these' />;\n    case 'none':\n      return <FormattedMessage id='hashtag.column_settings.tag_mode.none' defaultMessage='None of these' />;\n    default:\n      return '';\n    }\n  };\n\n  render () {\n    const { settings, onChange } = this.props;\n\n    return (\n      <div>\n        <div className='column-settings__row'>\n          <div className='setting-toggle'>\n            <Toggle id='hashtag.column_settings.tag_toggle' onChange={this.onToggle} checked={this.state.open} />\n\n            <span className='setting-toggle__label'>\n              <FormattedMessage id='hashtag.column_settings.tag_toggle' defaultMessage='Include additional tags in this column' />\n            </span>\n          </div>\n        </div>\n\n        {this.state.open && (\n          <div className='column-settings__hashtags'>\n            {this.modeSelect('any')}\n            {this.modeSelect('all')}\n            {this.modeSelect('none')}\n          </div>\n        )}\n\n        <div className='column-settings__row'>\n          <SettingToggle settings={settings} settingPath={['local']} onChange={onChange} label={<FormattedMessage id='community.column_settings.local_only' defaultMessage='Local only' />} />\n        </div>\n      </div>\n    );\n  }\n\n}\n","import { connect } from 'react-redux';\nimport ColumnSettings from '../components/column_settings';\nimport { changeColumnParams } from 'flavours/glitch/actions/columns';\nimport api from 'flavours/glitch/util/api';\n\nconst mapStateToProps = (state, { columnId }) => {\n  const columns = state.getIn(['settings', 'columns']);\n  const index   = columns.findIndex(c => c.get('uuid') === columnId);\n\n  if (!(columnId && index >= 0)) {\n    return {};\n  }\n\n  return {\n    settings: columns.get(index).get('params'),\n    onLoad (value) {\n      return api(() => state).get('/api/v2/search', { params: { q: value, type: 'hashtags' } }).then(response => {\n        return (response.data.hashtags || []).map((tag) => {\n          return { value: tag.name, label: `#${tag.name}` };\n        });\n      });\n    },\n  };\n};\n\nconst mapDispatchToProps = (dispatch, { columnId }) => ({\n  onChange (key, value) {\n    dispatch(changeColumnParams(columnId, key, value));\n  },\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ColumnSettings);\n","import api from 'flavours/glitch/util/api';\n\nexport const HASHTAG_FETCH_REQUEST = 'HASHTAG_FETCH_REQUEST';\nexport const HASHTAG_FETCH_SUCCESS = 'HASHTAG_FETCH_SUCCESS';\nexport const HASHTAG_FETCH_FAIL    = 'HASHTAG_FETCH_FAIL';\n\nexport const HASHTAG_FOLLOW_REQUEST = 'HASHTAG_FOLLOW_REQUEST';\nexport const HASHTAG_FOLLOW_SUCCESS = 'HASHTAG_FOLLOW_SUCCESS';\nexport const HASHTAG_FOLLOW_FAIL    = 'HASHTAG_FOLLOW_FAIL';\n\nexport const HASHTAG_UNFOLLOW_REQUEST = 'HASHTAG_UNFOLLOW_REQUEST';\nexport const HASHTAG_UNFOLLOW_SUCCESS = 'HASHTAG_UNFOLLOW_SUCCESS';\nexport const HASHTAG_UNFOLLOW_FAIL    = 'HASHTAG_UNFOLLOW_FAIL';\n\nexport const fetchHashtag = name => (dispatch, getState) => {\n  dispatch(fetchHashtagRequest());\n\n  api(getState).get(`/api/v1/tags/${name}`).then(({ data }) => {\n    dispatch(fetchHashtagSuccess(name, data));\n  }).catch(err => {\n    dispatch(fetchHashtagFail(err));\n  });\n};\n\nexport const fetchHashtagRequest = () => ({\n  type: HASHTAG_FETCH_REQUEST,\n});\n\nexport const fetchHashtagSuccess = (name, tag) => ({\n  type: HASHTAG_FETCH_SUCCESS,\n  name,\n  tag,\n});\n\nexport const fetchHashtagFail = error => ({\n  type: HASHTAG_FETCH_FAIL,\n  error,\n});\n\nexport const followHashtag = name => (dispatch, getState) => {\n  dispatch(followHashtagRequest(name));\n\n  api(getState).post(`/api/v1/tags/${name}/follow`).then(({ data }) => {\n    dispatch(followHashtagSuccess(name, data));\n  }).catch(err => {\n    dispatch(followHashtagFail(name, err));\n  });\n};\n\nexport const followHashtagRequest = name => ({\n  type: HASHTAG_FOLLOW_REQUEST,\n  name,\n});\n\nexport const followHashtagSuccess = (name, tag) => ({\n  type: HASHTAG_FOLLOW_SUCCESS,\n  name,\n  tag,\n});\n\nexport const followHashtagFail = (name, error) => ({\n  type: HASHTAG_FOLLOW_FAIL,\n  name,\n  error,\n});\n\nexport const unfollowHashtag = name => (dispatch, getState) => {\n  dispatch(unfollowHashtagRequest(name));\n\n  api(getState).post(`/api/v1/tags/${name}/unfollow`).then(({ data }) => {\n    dispatch(unfollowHashtagSuccess(name, data));\n  }).catch(err => {\n    dispatch(unfollowHashtagFail(name, err));\n  });\n};\n\nexport const unfollowHashtagRequest = name => ({\n  type: HASHTAG_FETCH_REQUEST,\n  name,\n});\n\nexport const unfollowHashtagSuccess = (name, tag) => ({\n  type: HASHTAG_FETCH_SUCCESS,\n  name,\n  tag,\n});\n\nexport const unfollowHashtagFail = (name, error) => ({\n  type: HASHTAG_FETCH_FAIL,\n  name,\n  error,\n});\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport PropTypes from 'prop-types';\nimport StatusListContainer from 'flavours/glitch/features/ui/containers/status_list_container';\nimport Column from 'flavours/glitch/components/column';\nimport ColumnHeader from 'flavours/glitch/components/column_header';\nimport ImmutablePropTypes from 'react-immutable-proptypes';\nimport ColumnSettingsContainer from './containers/column_settings_container';\nimport { expandHashtagTimeline, clearTimeline } from 'flavours/glitch/actions/timelines';\nimport { addColumn, removeColumn, moveColumn } from 'flavours/glitch/actions/columns';\nimport { connectHashtagStream } from 'flavours/glitch/actions/streaming';\nimport { injectIntl, FormattedMessage, defineMessages } from 'react-intl';\nimport { isEqual } from 'lodash';\nimport { fetchHashtag, followHashtag, unfollowHashtag } from 'flavours/glitch/actions/tags';\nimport Icon from 'flavours/glitch/components/icon';\nimport classNames from 'classnames';\n\nconst messages = defineMessages({\n  followHashtag: { id: 'hashtag.follow', defaultMessage: 'Follow hashtag' },\n  unfollowHashtag: { id: 'hashtag.unfollow', defaultMessage: 'Unfollow hashtag' },\n});\n\nconst mapStateToProps = (state, props) => ({\n  hasUnread: state.getIn(['timelines', `hashtag:${props.params.id}${props.params.local ? ':local' : ''}`, 'unread']) > 0,\n  tag: state.getIn(['tags', props.params.id]),\n});\n\nexport default @connect(mapStateToProps)\n@injectIntl\nclass HashtagTimeline extends React.PureComponent {\n\n  disconnects = [];\n\n  static propTypes = {\n    params: PropTypes.object.isRequired,\n    columnId: PropTypes.string,\n    dispatch: PropTypes.func.isRequired,\n    hasUnread: PropTypes.bool,\n    tag: ImmutablePropTypes.map,\n    multiColumn: PropTypes.bool,\n    intl: PropTypes.object,\n  };\n\n  handlePin = () => {\n    const { columnId, dispatch } = this.props;\n\n    if (columnId) {\n      dispatch(removeColumn(columnId));\n    } else {\n      dispatch(addColumn('HASHTAG', { id: this.props.params.id }));\n    }\n  }\n\n  title = () => {\n    const { id } = this.props.params;\n    const title  = [id];\n\n    if (this.additionalFor('any')) {\n      title.push(' ', <FormattedMessage key='any' id='hashtag.column_header.tag_mode.any'  values={{ additional: this.additionalFor('any') }} defaultMessage='or {additional}' />);\n    }\n\n    if (this.additionalFor('all')) {\n      title.push(' ', <FormattedMessage key='all' id='hashtag.column_header.tag_mode.all'  values={{ additional: this.additionalFor('all') }} defaultMessage='and {additional}' />);\n    }\n\n    if (this.additionalFor('none')) {\n      title.push(' ', <FormattedMessage key='none' id='hashtag.column_header.tag_mode.none' values={{ additional: this.additionalFor('none') }} defaultMessage='without {additional}' />);\n    }\n\n    return title;\n  }\n\n  additionalFor = (mode) => {\n    const { tags } = this.props.params;\n\n    if (tags && (tags[mode] || []).length > 0) {\n      return tags[mode].map(tag => tag.value).join('/');\n    } else {\n      return '';\n    }\n  }\n\n  handleMove = (dir) => {\n    const { columnId, dispatch } = this.props;\n    dispatch(moveColumn(columnId, dir));\n  }\n\n  handleHeaderClick = () => {\n    this.column.scrollTop();\n  }\n\n  _subscribe (dispatch, id, tags = {}, local) {\n    let any  = (tags.any || []).map(tag => tag.value);\n    let all  = (tags.all || []).map(tag => tag.value);\n    let none = (tags.none || []).map(tag => tag.value);\n\n    [id, ...any].map(tag => {\n      this.disconnects.push(dispatch(connectHashtagStream(id, tag, local, status => {\n        let tags = status.tags.map(tag => tag.name);\n\n        return all.filter(tag => tags.includes(tag)).length === all.length &&\n               none.filter(tag => tags.includes(tag)).length === 0;\n      })));\n    });\n  }\n\n  _unsubscribe () {\n    this.disconnects.map(disconnect => disconnect());\n    this.disconnects = [];\n  }\n\n  _unload () {\n    const { dispatch } = this.props;\n    const { id, local } = this.props.params;\n\n    this._unsubscribe();\n    dispatch(clearTimeline(`hashtag:${id}${local ? ':local' : ''}`));\n  }\n\n  _load() {\n    const { dispatch } = this.props;\n    const { id, tags, local } = this.props.params;\n\n    this._subscribe(dispatch, id, tags, local);\n    dispatch(expandHashtagTimeline(id, { tags, local }));\n    dispatch(fetchHashtag(id));\n  }\n\n  componentDidMount () {\n    this._load();\n  }\n\n  componentDidUpdate (prevProps) {\n    const { params } = this.props;\n    const { id, tags, local } = prevProps.params;\n\n    if (id !== params.id || !isEqual(tags, params.tags) || !isEqual(local, params.local)) {\n      this._unload();\n      this._load();\n    }\n  }\n\n  componentWillUnmount () {\n    this._unsubscribe();\n  }\n\n  setRef = c => {\n    this.column = c;\n  }\n\n  handleLoadMore = maxId => {\n    const { dispatch, params } = this.props;\n    const { id, tags, local }  = params;\n\n    dispatch(expandHashtagTimeline(id, { maxId, tags, local }));\n  }\n\n  handleFollow = () => {\n    const { dispatch, params, tag } = this.props;\n    const { id } = params;\n\n    if (tag.get('following')) {\n      dispatch(unfollowHashtag(id));\n    } else {\n      dispatch(followHashtag(id));\n    }\n  }\n\n  render () {\n    const { hasUnread, columnId, multiColumn, tag, intl } = this.props;\n    const { id, local } = this.props.params;\n    const pinned = !!columnId;\n\n    let followButton;\n\n    if (tag) {\n      const following = tag.get('following');\n\n      followButton = (\n        <button className={classNames('column-header__button')} onClick={this.handleFollow} title={intl.formatMessage(following ? messages.unfollowHashtag : messages.followHashtag)} aria-label={intl.formatMessage(following ? messages.unfollowHashtag : messages.followHashtag)} aria-pressed={following ? 'true' : 'false'}>\n          <Icon id={following ? 'user-times' : 'user-plus'} fixedWidth className='column-header__icon' />\n        </button>\n      );\n    }\n\n    return (\n      <Column bindToDocument={!multiColumn} ref={this.setRef} label={`#${id}`}>\n        <ColumnHeader\n          icon='hashtag'\n          active={hasUnread}\n          title={this.title()}\n          onPin={this.handlePin}\n          onMove={this.handleMove}\n          onClick={this.handleHeaderClick}\n          pinned={pinned}\n          multiColumn={multiColumn}\n          extraButton={followButton}\n          showBackButton\n        >\n          {columnId && <ColumnSettingsContainer columnId={columnId} />}\n        </ColumnHeader>\n\n        <StatusListContainer\n          trackScroll={!pinned}\n          scrollKey={`hashtag_timeline-${columnId}`}\n          timelineId={`hashtag:${id}${local ? ':local' : ''}`}\n          onLoadMore={this.handleLoadMore}\n          emptyMessage={<FormattedMessage id='empty_column.hashtag' defaultMessage='There is nothing in this hashtag yet.' />}\n          bindToDocument={!multiColumn}\n        />\n      </Column>\n    );\n  }\n\n}\n"],"sourceRoot":""}